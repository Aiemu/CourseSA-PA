# PA1 Report
2017011438 曾正

## 开发运行环境
- macOS Catalina 10.15.3
- CLion 2019.2

## Part 1
### 实现说明
- 主要代码及实现思路（$pa1/dpll/Solver.c$）
  - $decide()$  
    首先随机选择变量，随机分配值（$true/false$），压栈并标记。进入$unitPropatation$进行推理，由$unitPropatation$返回后重复上述过程，直到搜索过所有变量并返回$True$，或查询到冲突，此时将该结点的值修改（$true<=>false$），若修改后依旧冲突则进入$backTrack$进行回溯。

  - $backTrack()$  
    反复弹栈直到回到上一个$decide$决策结点，修改该结点的值（$true<=>false$），若依旧冲突则重复上述过程，否则返回到$decide$继续决策或推理。

  - $unitPropagation()$  
    选择与之前结点（当前结点到上一$decide$决策结点）相关的$clause$进行推理确定取值，重复上述过程直到无法继续推理，则回到$decide$继续决策过程，或所有结点均有合适取值，则返回$true$。  

  上述过程实际上就是dfs，持续向下搜索，直到遇到冲突，逐步回溯，重复上述过程直到找到一组合适的取值（$SAT$），或找不到（$UNSAT$）。



## Part 2
### 实现说明
- 主要代码（$pa1/dpll/Solver.c$）
  - $backJump()$  
    $backJump$的主要思想是加强$backTrack$的效果，即一次能够回跳多步（不仅是多步$Propagation$推理结点，甚至能回跳多步$decide$决策结点）。这有赖于冲突子句$Conflict\_clause$的实现。在课堂上决定冲突子句$Conflict\_clause$是通过构造蕴含图并转化为冲突图，将冲突图进行划分（源结点和冲突结点分离）从而得到的冲突子句。在代码实现时，按照上述方式，作图并取划分是复杂且低效的，故使用的是冲突图的实现思想，并使用最简单的划分（所有源结点一组，其他所有结点一组）。由于在计算时是会记录下过程中所有经过的结点，并能够知道冲突所发生的$clause$，忽略无关$decide$决策结点和$propagation$推理结点后便可以找出冲突发生的源结点及其取值，即可得到冲突子句，添加到子句后便可实现多步回跳，即$backJump$。

### 结果比较
| Test ID | DPLL / $ms$ | CDCL / $ms$ |
|:---:|:---:|:---:|
| 18 | $8829.32$ | $51.5356$ |
| 16 | $11216.12$ | $181.046$ |
| 14 | $7387.09$ | $452$ |
| 12 | $7253.85$ | $103.075$ |
| 6 | $1.12549$ | $6.60589$ |
| 4 | $8.1996$ | $14.1618$ |
| 2 | $0.03306$ | $0.253664$ |

- 由上述实验结果可知实现$backJump$后计算速度得到了极为有效的提高，尤其是$test12$等数据为预设且有一定规律的输入，运算速度大大增加。此外$test18$等有大量$var$和$clause$的通常也会有较大的性能提升。这均是由于上述两种情况均有很大可能由于$backJump$一次回跳多步以省略大量不必要的运算。  

- 但我们也注意到在$var$和$clause$较少的时候，CDCL的运算速度反而会有一定幅度的下降，这一方面是由于我两者实现方式的不同（CDCL创建一个较为复杂的$Solver$对象用于计算，而DPLL仅仅在$check\_sat()$函数中实现），更重要的是CDCL会浪费一定时间在计算$conflict\_clause$上，但却无法一次实现一次回跳很多步。